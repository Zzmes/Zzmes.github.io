<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TVM 学习笔记（一） 初识 TVM</title>
    <link href="/2025/01/30/tvm-1/"/>
    <url>/2025/01/30/tvm-1/</url>
    
    <content type="html"><![CDATA[<h1 id="引言---什么是机器学习编译">引言 - 什么是机器学习编译</h1><ul><li>机器学习编译 (machine learning compilation, MLC)是指，将机器学习算法从开发阶段，通过变换和优化算法，使其变成部署状态。<ul><li>开发形式：是指我们在开发机器学习模型时使用的形式。典型的开发形式包括用PyTorch、TensorFlow 或 JAX等通用框架编写的模型描述，以及与之相关的权重。</li><li>部署形式：是指执行机器学习应用程序所需的形式。它通常涉及机器学习模型的每个步骤的支撑代码、管理资源（例如内存）的控制器，以及与应用程序开发环境的接口。</li></ul></li></ul><h1 id="为什么需要深度学习编译器">为什么需要深度学习编译器</h1><ul><li><p>从训练框架角度来看，Google的TensorFlow和FaceBook的Pytorch是全球主流的深度学习框架，另外亚马逊的MxNet，百度的Paddle，旷视的MegEngine，华为的Mindspore以及一流科技的OneFlow也逐渐在被更多人接受和使用。这么多训练框架，我们究竟应该选择哪个？如果追求易用性，可能你会选择Pytorch，如果追求项目部署落地，可能你会选择TensorFlow，如果追求分布式训练最快可能你会体验OneFlow。</p></li><li><p>从推理框架角度来看，无论我们选择何种训练框架训练模型，我们最终都是要将训练好的模型部署到实际场景的，在模型部署的时候我们会发现我们要部署的设备可能是五花八门的，例如IntelCPU/Nvidia GPU/Intel GPU/Arm CPU/ArmGPU/FPGA/NPU(华为海思)/BPU(地平线)/MLU(寒武纪)，如果我们要手写一个用于推理的框架在所有可能部署的设备上都达到良好的性能并且易于使用是一件非常困难的事。</p></li></ul><p>一般要部署模型到一个指定设备上，我们一般会使用硬件厂商自己推出的一些前向推理框架，例如在Intel的CPU/GPU上就使用OpenVINO，在Arm的CPU/GPU上使用NCNN/MNN等，在NvidiaGPU上使用TensorRT。虽然针对不同的硬件设备我们使用特定的推理框架进行部署是最优的，但这也同时存在问题，比如一个开发者训练了一个模型需要在多个不同类型的设备上进行部署，那么开发者需要将训练的模型分别转换到特定框架可以读取的格式，并且还要考虑各个推理框架算子实现是否完全对齐的问题，然后在不同平台部署时还容易出现的问题是开发者训练的模型在一个硬件上可以高效推理，部署到另外一个硬件上性能骤降。并且从探索ONNX模型转换来看，不同框架间模型转换工作也是阻碍各种训练框架模型快速落地的一大原因。</p><h1 id="深度学习编译器与传统编译器">深度学习编译器与传统编译器</h1><p>现代传统编译器（LLVM为例）包含编译器前端，编译器中端，编译器后端等概念，并引入IR(Intermediate Representation)的概念。解释如下： -编译器前端：接收C/C++/Java等不同语言，进行代码生成，吐出IR -编译器中端：接收IR，进行不同编译器后端可以共享的优化，如常量替换，死代码消除，循环优化等，吐出优化后的IR-编译器后端：接收优化后的IR，进行不同硬件的平台相关优化与硬件指令生成，吐出目标文件</p><figure><img src="/img/tvm/compie.png" alt="传统编译器编译流程" /><figcaption aria-hidden="true">传统编译器编译流程</figcaption></figure><p>受到传统编译器的启发，深度学习编译器被提出，我们可以将各个训练框架训练出来的模型看作各种编程语言，然后将这些模型传入深度学习编译器之后吐出IR，由于深度学习的IR其实就是计算图，所以可以直接叫作GraphIR。针对这些GraphIR可以做一些计算图优化再吐出IR分发给各种硬件使用。这样，深度学习编译器的过程就和传统的编译器类似，可以解决上面提到的很多繁琐的问题。<img src="/img/tvm/tvm-compie.png"alt="深度学习编译器(TVM)编译流程" /></p><h1 id="tvm">TVM</h1><p>TVM 是一个用于 CPU、GPU和机器学习加速器的开源机器学习编译器框架，旨在让机器学习工程师能够在任何硬件后端上高效地优化和运行计算。<img src="/img/tvm/tvm.png" alt="TMV" /></p><p>从这个图中我们可以看到，TVM架构的核心部分就是Relay编译器。Relay编译器支持直接接收深度学习框架的模型，如TensorFlow/Pytorch/Caffe/MxNet等，同时也支持一些模型的中间格式如ONNX、CoreML。这些模型被Relay直接编译成GraphIR，然后这些Graph IR被再次优化，吐出优化后的GraphIR，最后对于不同的后端这些GraphIR都会被编译为特定后端可以识别的机器码完成模型推理。比如对于CPU，NNVM就吐出LLVM可以识别的IR，再通过LLVM编译器编译为机器码到CPU上执行。</p><h1 id="tvm-环境配置">TVM 环境配置</h1><p>环境要求：GCC 7.1，CMake 3.18 或更高版本，推荐使用 LLVM 构建 TVM库以启用所有功能，如需使用 CUDA，请确保 CUDA 工具包的版本至少在 8.0以上，Python推荐使用3.8.X+版本。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --recursive https://github.com/apache/tvm tvm<br><span class="hljs-built_in">cd</span> tvm<br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cp</span> cmake/config.cmake build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br>make -j4<br><span class="hljs-built_in">export</span> TVM_HOME=/path/to/tvm<br><span class="hljs-built_in">export</span> PYTHONPATH=<span class="hljs-variable">$TVM_HOME</span>/python:<span class="hljs-variable">$&#123;PYTHONPATH&#125;</span><br></code></pre></td></tr></table></figure>在此之前需要安装llvm，直接在官网上下载已经编译好的文件。需要开启 CUDA等功能见官方文档修改相应的config.cmake。</p>]]></content>
    
    
    <categories>
      
      <category>模型部署</category>
      
      <category>TVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CUDA 编程（二） GPU 编程与 CUDA</title>
    <link href="/2025/01/25/CUDA-2/"/>
    <url>/2025/01/25/CUDA-2/</url>
    
    <content type="html"><![CDATA[<h1 id="cuda-编程并行计算整体流程">CUDA 编程并行计算整体流程</h1><p><img src="/img/cuda/cudapipe.png" alt="CUDAPipe" /> -从主机端申请内存，把内存的部分内容拷贝到设备端（GPU） - CPU调度在设备端的核函数计算（异步）---&gt; 核函数：设备段执行的函数 -从设备端拷贝到主机端，并释放内存显存</p><h1 id="cuda-内存模型">CUDA 内存模型</h1><ul><li>CUDA 中的内存模型分为以下几个层次（硬件）：<ul><li>每个线程处理器（SP）都有自己的寄存器</li><li>每个 SP 都有自己的局部内存，寄存器和局部内存只能被线程自己访问</li><li>每个多核处理器（SM）内都有自己的共享内存，共享内存可以被线程块内（block）所有线程访问</li><li>一个 GPU 的所有 SM 共有一块全局内存，不同线程块的线程都可以使用</li></ul></li><li>CUDA 中的内存模型分为以下几个层次（软件）：<ul><li>线程处理器（SP）对应线程（thread）</li><li>多核处理器（SM）对应线程块（block）</li><li>设备端（device）对应网格（grid）</li><li>一个 kernel 其实由一个 grid 执行</li><li>一个 kernel 一次只能在一个 GPU 上执行</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA 与 TensorRT 部署</category>
      
      <category>CUDA</category>
      
      <category>TensorRT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA 编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA 编程（一） CPU 与 GPU 的基本知识</title>
    <link href="/2025/01/24/CUDA-1/"/>
    <url>/2025/01/24/CUDA-1/</url>
    
    <content type="html"><![CDATA[<h1 id="重要指标">重要指标</h1><ul><li>延迟：一条指令从发出到返回结果所经历的时间间隔</li><li>吞吐量：单位时间内执行的指令数</li></ul><h1 id="cpu延迟导向设计">CPU:延迟导向设计</h1><p><img src="/img/cuda/cpu.png" alt="CPU" /> - CPU 设计原则：减少延迟 -CPU 特点： -内存大：本着空间换时间的原则，拥有多级缓存结构提高访存速度（L1 Cache、L2Cache...），把经常访问的数据放在低级缓存 L1Cache中，不常访问的数据放在高级缓存 L3 Cache中 - 有很多复杂的控制单元：- 分支预测机制 --&gt; 在硬件中判断语言的 if else break continue 执行； -流水线数据前送机制 --&gt;判断如果马上要访问的数据，会用流水线机制把数据尽可能向前推送，减少等待时间- 运算单元强大： - 支持整型、浮点型数据运算 -支持与、或、非、逻辑运算</p><h1 id="gpu吞吐量导向设计">GPU:吞吐量导向设计</h1><p><img src="/img/cuda/gpu.png" alt="GPU" /> - GPU设计原则：增加指令吞吐 - GPU 特点： - 缓存小（如图 L2 Cache）： - 缓存小--&gt; 指令访问缓存的次数显著减少 --&gt; 提升内存访问吞吐 -控制单元简单： - 没有分支预测机制 - 没有数据转发机制 - 精简运算单元 -多长延时流水线以提高吞吐量（一行很多运算单元） -需要大量线程来容忍延迟（每一行的运算单元控制指令只有一个）</p><h1 id="gpu-与-cpu-对比">GPU 与 CPU 对比</h1><ul><li>CPU 比 GPU，单条复杂指令延迟快 10 倍以上</li><li>GPU 比 CPU，单位时间内执行指令数量快 10 倍以上</li></ul><h1 id="适合使用-gpu-的场景">适合使用 GPU 的场景</h1><ul><li>计算密集的程序适合在 GPU:数值计算的比例要远大于内存操作，因此内存访问的延迟可以被计算覆盖</li><li>并行度高的程序适合在 GPU:大任务可以拆分为执行相同指令的小任务，对复杂流程控制的需求较低</li><li>控制复杂的程序</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA 与 TensorRT 部署</category>
      
      <category>CUDA</category>
      
      <category>TensorRT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA 编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式系统学习（四）：文件 IO</title>
    <link href="/2024/10/14/Embedded-4/"/>
    <url>/2024/10/14/Embedded-4/</url>
    
    <content type="html"><![CDATA[<h1 id="day01">Day01</h1><h2 id="计算机组成部分">计算机组成部分</h2><h3 id="硬件系统">硬件系统</h3><p>计算机的硬件主要是由五部分组成：控制器、运算器、存储器、输入设备、输出设备。其中运算器和控制器的总称是中央处理器（CPU），指的是计算机中对信息进行高速运算处理的主要部件。</p><p>存储器则是用来存储程序、数据和文件，一般是由快速的内部存储器（容量可达数百兆字节，甚至数G字节）和慢速的外部存储器（容量可达数十G或数百G以上）组成，比如计算机中的内存条和固态硬件就属于存储器。<img src="/img/embeding/emb-1.png" alt="计算机组成部分" />输入设备与输出设备就是用于实现人机交互的信息转换器，由计算机的输入输出控制系统负责管理外部设备与主存储器之间的信息交换，常用的输入设备主要有键盘以及鼠标，输出设备则是显示器、打印机以及其他可连接到计算机上的I/O设备。</p><h3 id="软件系统">软件系统</h3><p>如果计算机只有硬件系统，那么计算机是无法正常工作的，因为计算机是由基本的电子元件组成的，而电子元件的状态是需要由软件来控制的，所以计算机必须要搭载软件系统，计算机的软件系统与硬件系统是互相依赖的。</p><p>计算机的软件系统一般由两部分组成：系统软件、应用软件。系统软件指的是计算机中的操作系统以及硬件驱动程序等，应用软件指的是用户可以使用的各种程序设计语言以及利用程序设计语言设计的应用程序的集合。</p><h3 id="文件系统">文件系统</h3><p>计算机的系统软件和应用软件其实都是大量的程序和数据组成的，也就是说两者都需要存储在计算机的存储器中，这些程序和数据以什么样的格式存储到存储器中就由文件系统决定。</p><p>大家可以把文件系统理解为是一种“标准”或者“格式”，只要遵循这套标准就可以正确的访问存储在磁盘中的数据。</p><p>当然，标准的制定则是至关重要，但是由于技术原因或者商业利益考虑，导致现在文件系统没有办法统一。所以目前存在多种文件系统，常见的有FAT32、NTFS、ext4......，比如电脑的本地磁盘的文件系统就是NTFS格式。</p><p>Linux系统也支持多种文件系统类型，可以在Linux系统根目录的/proc目录下查阅filesystems<img src="/img/embeding/emb-2.png" alt="Linux 支持的文件系统格式" /></p><p>计算机中搭载的Linux操作系统就属于系统软件，操作系统的作用是用来连接应用软件和底层硬件，因为涉及到Linux内核的安全管理机制，所以用户空间是没有办法直接访问硬件设备的。<img src="/img/embeding/emb-2.png" /></p><p>那么用户必须要通过Linux内核提供的相关函数接口才能实现硬件的控制，这样用户也不需要关心硬件应该如何控制，只需要把参数提交给内核，然后由内核把控制参数传递给硬件设备，从而让内核控制硬件设备完成相关动作。</p><p>也正因如此，用户需要先利用程序设计语言设计出源文件（xxx.c），然后操作系统内核需要从磁盘中访问源文件，再通过编译器把源文件编译生成可执行文件，最后内核再访问存储在磁盘中的可执行文件，从而把控制硬件的参数读取出来。</p><p>所以访问磁盘中的文件也是操作系统要做的工作之一。所以操作系统和文件系统可以理解为一种“合作”关系，文件系统指定了读写文件的标准，而操作系统会按照这套标准去完成访问文件的动作。</p><h3 id="linux系统的目录">Linux系统的目录</h3><h4 id="根文件系统说明">根文件系统说明</h4><p>需要注意：Linux系统是离不开文件系统的，在Linux内核启动之后首先搭载的就是根文件系统rootfs，根文件系统rootfs本质就是文件系统，只不过是Linux内核挂载的第一个文件系统。而Linux内核源码是存储在文件系统中，所以在linux系统启动的过程中启动引导程序uboot会加载内核并利用内核挂载根文件系统。<img src="/img/embeding/emb-4.png" /></p><p>根文件系统被挂载之后，一些服务程序和一些脚本文件才可以存储在文件系统中，其他的文件系统才可以被挂载。</p><p>根文件系统会提供一些服务：比如根文件系统会提供一个根目录（存储文件和目录）、提供一个shell终端（用户才可以输入命令）、根文件系统会存储应用程序。总而言之，Linux内核离开根文件系统是无法正常工作的。</p><p><img src="/img/embeding/emb-5.png" />Linux系统的所有程序和数据都是以“文件”的形式存储在文件系统中，所有Linux用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。这种机制有利于用户和操作系统的交互，这也是Linux系统“一切皆文件”的原因。</p><p>其实就是借鉴了Unix系统的设计风格，体现了面向对象的设计思想，把脚本、文档、硬件设备等都抽象为文件对象，再通过统一的POSIX操作接口对文件进行操作，简化了操作难度。</p><h4 id="目录的结构分析">目录的结构分析</h4><p>在 Linux操作系统中，所有的文件和目录都被组织成以一个根节点“/”开始的倒置的树状结构。如下图：<img src="/img/embeding/emb-6.png" /></p><p>文件系统的最顶层是由根目录开始的，系统使用“/”来表示根目录，在根目录之下的既可以是目录（目录就相当于Windows中的文件夹），也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。</p><p>使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。</p><p>同样，为了方便观察Linux系统的目录结构，所以Linux内核也提供了一个shell命令：tree，该命令可以以树状结构打印出目录的层次，当然，tree命令需要在Linux系统中提前安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span>  apt-get  install  tree<br></code></pre></td></tr></table></figure><h4 id="linux的文件类型">Linux的文件类型</h4><p>由于程序和数据在Linux系统中都是以文件的形式存在，那不同格式的数据所对应的文件类型也各不相同，在Linux系统下可以把文件的类型分为以下七种：1) 普通文件 ：存在于外部存储器中，用于存储普通数据。 2) 目录文件：用于存放目录项，是文件系统管理的重要文件类型。 3) 管道文件：一种用于进程间通信的特殊文件，也称为命名管道FIFO。 4) 套接字文件：一种用于网络间通信的特殊文件。 5) 链接文件：用于间接访问另外一个目标文件，相当于windows快捷方式。 6)字符设备文件：字符设备在应用层的访问接口。 7) 块设备文件：块设备在应用层的访问接口。</p><h4 id="文件操作接口说明">文件操作接口说明</h4><p>上面提到数据都是以文件的形式存储在Linux系统中，并且Linux系统为了简化不同类型文件的操作流程，在设计访问接口时也遵循POSIX标准，而POSIX标准就是对不同操作系统的访问接口做出统一的规范，目的是提高程序的兼容性和可移植性。</p><p>大家经常使用的C语言同样具有语法标准，并且C语言标准在发布的时候也会发布对应的库函数提供给用户。这些库函数也同样遵循POSIX标准进行设计，而遵循POSIX标准设计出来的函数的集合也被称为标准库，比如大家使用的标准C库中提供了标准的输入输出函数，这些函数在Linux系统可以使用，同样也可以在Windows系统中使用。用户可以根据标准输入输出头文件&lt;stdio.h&gt;中的函数声明进行调用，Linux系统下该头文件路径为/usr/include。</p><p>另外，由于任何一种操作系统都会有访问磁盘文件的需求，所以POSIX标准中同样对访问文件的输入输出接口做出了约束，这些访问文件的函数接口在C语言标准中都有具体的描述。</p><p>标准C库中关于文件输入输出的函数接口一般被称为标准IO，访问文件常用的标准IO函数有fopen()、fread()、fwrite()、fclose()、fgetc()、fputc()、fgets()、fputs()、fprintf()、fscanf()等。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>Linux 文件 IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 多进程、多线程、IO 模型(一)</title>
    <link href="/2024/10/11/c-thread/"/>
    <url>/2024/10/11/c-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="进程">进程</h1><h2 id="进程的概念">进程的概念</h2><p>进程描述是一个程序执行过程，当程序执行后，执行过程开始，则进程产生,执行过程结束, 则进程也就结束。</p><h2 id="进程的特点">进程的特点</h2><ul><li>进程是一个独立的可调度的活动, 由操作系统进行统一调度,相应的任务会被调度到 CPU 中进行执行；</li><li>进程一旦产生，则需要分配相关资源，同时进程是资源分配的最小单位；</li></ul><h2 id="进程和程序的区别">进程和程序的区别</h2><ul><li>程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念；</li><li>进程是一个动态的概念，它是程序执行的过程，包括了动态创建、调度和消亡的整个过程</li></ul><h2 id="并行执行和并发执行">并行执行和并发执行</h2><ul><li>并行执行: 表示多个任务能够同时执行，依赖于物理的支持，比如 cpu 是 4核心，则可以同时执行 4 个任务</li><li>并发执行:在同一时间段有多个任务在同时执行，由操作系统调度算法来实现，比较典型的就是时间片轮转<img src="/img/example/C_CPP/C_1.png" alt="network1" /></li></ul><h2 id="linux-系统中管理进程的方式">Linux 系统中管理进程的方式</h2><ul><li>每个进程都需要与其他某一个进程建立父子关系,对应的进程则叫做父进程；</li><li>Linux 系统会为每个进程分配 id , 这个 id 作为当前进程的唯一标识,当进程结束, 则会回收；</li><li>进程的 id 与 父进程的 id 分别通过 getpid() 与 getppid() 来获取<ul><li>例如以下代码就是获取当前进程 id 以及父进程 id： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; pid : %d ppid : %d\n&quot;</span>,getpid(),getppid());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> #进程的地址空间 ## 进程的地址空间</li></ul></li><li>一旦进程建立之后, 系统则要为这个进程分配相应的资源, 一般 32位系统会为每个进程分配 4G 的地址空间；<ul><li>4G 的地址空间结构如下:<img src="/img/example/C_CPP/C_2.png"alt="network1" /><ul><li>4G 的进程地址空间主要分为两部分:<ul><li>（1）0 - 3G: 用户空间;</li><li>（2）3G - 4G: 内核空间;</li></ul></li><li>用户空间又具体分为如下区间:<ul><li>stack: 存放非静态的局部变量</li><li>heap: 动态申请的内存</li><li>.bss: 未初始化过的全局变量（包括初始化为 0 的, 未初始化过的静态变量(包括初始化为 0)</li><li>data: 初始化过并且值不为 0 的全局变量, 初始化过的不为 0静态变量</li><li>.rodata: 只读变量（字符串之类）</li><li>.text: 程序文本段（包括函数，符号常量）</li></ul></li></ul></li></ul></li><li>当用户进程需要通过内核获取资源时, 会切换到内核态运行,这时当前进程会使用内核空间的资源；</li><li>用户需要切换到内核态运行时, 主要是通过 系统调用</li><li>在程序执行过程中，操作系统会分配 4G 的虚拟地址空间</li><li>虚拟地址空间中的每个地址都是一个虚拟地址<ul><li>虚拟地址：虚拟地址并不代表真实的内存空间,而是一个用于寻址的编号</li><li>物理地址：是指内存设备中真实存在的存储空间的编号</li></ul></li><li>虚拟地址通过映射的方式建立与物理地址的关联,从而达到访问虚拟地址就可以访问到对应的物理地址<ul><li>在 cpu 中有一个硬件 MMU(内存管理单元),负责虚拟地址与物理地址的映射管理以及虚拟地址访问</li><li>操作系统可以设置 MMU 中的映射内存段<imgsrc="/img/example/C_CPP/C_3.png" alt="network1" /></li></ul></li><li>在操作系统中使用虚拟地址空间主要是基于以下原因:<ul><li>直接访问物理地址, 会导致地址空间没有隔离, 很容易导致数据被修改</li><li>通过虚拟地址空间可以实现每个进程地址空间都是独立的，操作系统会映射到不用的物理地址区间，在访问时互不干扰</li></ul></li></ul><h1 id="进程的状态管理">进程的状态管理</h1><ul><li>进程是动态过程，操作系统内核在管理整个动态过程时会使用了状态机<ul><li>给不同时间节点设计一个状态，通过状态来确定当前的过程进度</li><li>在管理动态过程时，使用状态机是一种非常好的方式</li></ul></li><li>进程的状态一般分为如下:<ul><li>运行态 (TASK_RUNNING): 此时进程或者正在运行，或者准备运行,就绪或者正在进行都属于运行态</li><li>睡眠态 (): 此时进程在等待一个事件的发生或某种系统资源<ul><li>可中断的睡眠 (TASK_INTERRUPT):可以被信号唤醒或者等待事件或者资源就绪</li><li>不可中断的睡眠 (TASK_UNTERRUPT): 只能等待特定的事件或者资源就绪</li></ul></li><li>停止态 (TASK_STOPPED): 进程暂停接受某种处理。例如：gdb调试断点信息处理。</li><li>僵尸态（TASK_ZOMBIE）:进程已经结束但是还没有释放进程资源<imgsrc="/img/example/C_CPP/C_4.png" alt="network1" /></li></ul></li></ul><h1 id="进程的相关命令">进程的相关命令</h1><ul><li>ps:<ul><li>-A:列出所有的进程</li><li>-e: 与 -A 功能类似</li><li>-w: 显示加宽可以显示较多的资讯</li><li>-au: 显示较详细的信息</li><li>-aux: 显示所有包含其他使用者的进程 事例：ps -ef | grep“可执行文件名” 根据名称查找指定名字</li></ul></li><li>top：实时显示相关进程</li></ul><h1 id="进程的创建">进程的创建</h1><ul><li>为了提高计算机执行任务的效率，一般采用的解决方案就是能够让多个任务同时进行，这里可以使用并发与并行两种方式：<ul><li>并行: 在 cpu 多核的支持下，实现物理上的同时执行</li><li>并发: 在有限的 cpu 核心的情况下（如只有一个 cpu 核心）, 利用快速交替(时间片轮转) 执行来达到宏观上的同时执行</li></ul></li><li>并行是基于硬件完成，而并发则可以使用软件算法来完成,在完成任务时，可以创建多个进程并发执行</li><li>创建进程的函数需要调用 fork() 函数, 则会产生一个新的进程</li><li>调用 fork() 函数的进程叫做 父进程，产生的新进程则为子进程</li></ul><h2 id="fork函数详解">fork()函数详解</h2><ul><li>函数头文件： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>函数原型 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li>函数功能：创建一个子进程</li><li>函数返回值：<ul><li>成功: 返回给父进程是子进程的 pid , 返回给子进程的是 0</li><li>失败: 返回 -1, 并设置 errno</li></ul></li></ul><p>示例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> cpid;<br>    cpid = fork();<br>    <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fork(): &quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 输出两个 Hello world</span><br>&#125;<br></code></pre></td></tr></table></figure> - 之所以 显示两个 “helloworld”是因为打印语句在两个进程中都运行了,但是是父进程先执行还是子进程先执行取决于操作系统</p><p>示例 : 创建一个子进程，并打印 父进程与子进程的 pid： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> idata = <span class="hljs-number">200</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> istack = <span class="hljs-number">300</span>;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork():&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        idata *= <span class="hljs-number">2</span>;<br>        istack *= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s %d %d\n&quot;</span>,(pid == <span class="hljs-number">0</span>)?(<span class="hljs-string">&quot;child&quot;</span>):(<span class="hljs-string">&quot;parent&quot;</span>),idata,istack);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> -通过 fork() 函数创建子进程之后，有如下特点: - 父子进程并发执行, 子进程从fork() 之后开始执行<img src="/img/example/C_CPP/C_5.png"alt="network1" /> -父子进程的执行顺序由操作系统算法决定的，不是由程序本身决定 -子进程会拷⻉父进程地址空间的内容, 包括缓冲区、文件描述符等<imgsrc="/img/example/C_CPP/C_6.png" alt="network1" /></p><p>示例: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> cpid;<br>    write(STDOUT_FILENO,<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-built_in">stdout</span>);<br>    cpid = fork();<br>    <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>    perror(<span class="hljs-string">&quot;fork(): &quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 上面的代码最终会打印三次 Hello - 文件描述符拷⻉:- 每个进程都会维护一个文件表项，即文件描述符与文件指针的映射表 - 在Linux 内核中有一个 struct file 结构体来管理所有打开的文件 -当子进程拷⻉了父进程文件描述符后，则会共享文件状态标志与文件偏移量等信息<imgsrc="/img/example/C_CPP/C_7.png" alt="network1" /></p><h1 id="父子进程执行不同的任务">父子进程执行不同的任务</h1><ul><li>使用 fork() 函数之后，会创建子进程，fork()之后的代码会在父子进程中都执行一遍<ul><li>如果父子进程执行相同的任务，则正常执行</li><li>如果父子进程执行不同的任务，则需要利用 fork() 函数返回值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> cpid;<br>    cpid = fork();<br>    <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;[ERROR] fork()&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cpid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process task.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process task.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child and Process Process task.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>在创建多个进程时, 最主要的原则为 由父进程统一创建，统一管理,不能进行递归创建 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> cpid;<br>    cpid = fork();<br>    <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fork(): &quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The child process &lt; %d &gt; running...\n&quot;</span>,getpid());<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The child process &lt; %d &gt; has exited\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpid &gt; <span class="hljs-number">0</span>)&#123;<br>        cpid = fork();<br>    <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fork(): &quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The child process &lt; %d &gt; running...\n&quot;</span>,getpid());<br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The child process &lt; %d &gt; has exited\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpid &gt; <span class="hljs-number">0</span>)&#123;<br>        <br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> # 进程的退出</li><li>在进程结束时，需要释放进程地址空间 以及内核中产生的各种数据结构</li><li>源的释放需要通过调用 exit 函数或者 _exit 函数来完成</li><li>在程序结束时，会自动调用 exit 函数</li><li>exit 函数让当前进程退出, 并刷新缓冲区</li><li>exit 函数信息如下:<ul><li>函数头文件： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>函数原型 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br></code></pre></td></tr></table></figure></li><li>函数功能: 结束进程，并刷新缓冲区</li><li>函数参数:<ul><li>status: 退出状态值<ul><li>在系统中定义了两个状态值 : EXIT_SUCCESS: 正常退出 EXIT_FAILURE:异常退出, 具体定义在 stdlib.h 中</li></ul></li></ul></li></ul></li></ul><p>示例: 创建一个子进程，让子进程延时 3s 后退出: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> cpid;<br>    cpid = fork();<br>    <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;[ERROR] fork(): &quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cpid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process &lt; %d &gt; running...\n&quot;</span>,getpid());<br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process &lt; %d &gt; has exited.\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cpid &gt; <span class="hljs-number">0</span>)&#123;<br>        sleep(<span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>_exit 函数头文件 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>函数原型 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status);<br></code></pre></td></tr></table></figure></li><li>函数参数: status: 进程退出的状态值 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">pid_t</span> cpid;<br>cpid = fork();<br><span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>    perror(<span class="hljs-string">&quot;[ERROR] fork(): &quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cpid == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process &lt; %d &gt; running...\n&quot;</span>,getpid());<br>    sleep(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process &lt; %d &gt; has exited.\n&quot;</span>,getpid());<br>    _exit(EXIT_SUCCESS);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cpid &gt; <span class="hljs-number">0</span>)&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>exit 函数与 _exit 函数功能相似, 但有很多不同, 具体如下:<ul><li>_exit() 属于系统调用, 能够使进程停止运行,并释放空间以及销毁内核中的各种数据结构</li><li>exit() 基于_exit() 函数实现, 属于库函数, 可以清理 I/O 缓冲区</li></ul></li></ul><p>示例：验证 exit 函数刷新缓冲区: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> cpid;<br>    cpid = fork();<br>    <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;[ERROR] fork(): &quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cpid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I/O BUFFER.&quot;</span>);<br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cpid &gt; <span class="hljs-number">0</span>)&#123;<br>        sleep(<span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>C 语言基础</category>
      
      <category>嵌入式应用层开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式应用层开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络速通(七) 路由和寻址的区别是什么</title>
    <link href="/2024/10/09/network7/"/>
    <url>/2024/10/09/network7/</url>
    
    <content type="html"><![CDATA[<p>IP 协议是网络层协议，IP协议并不负责数据的可靠性，传输数据时，数据被拆分成一个个数据封包，IP协议上方的传输层协议会对数据进行一次拆分，IP协议还会进一步拆分，进行两次拆分的原因是为了适配底层的设备。</p><p>之前我们提到过，数据在网络中交换，也就是封包交换算法，并不需要预先建立一个连接，而是任由数据在网络中传输，每个节点通过路由算法帮助封包选择下一个目的地。</p><p>什么是可靠性？—— 可靠性就是保证数据无损地到达目的地。可靠性是 IP协议上方（Host to Host）协议保证的。比如 TCP协议通过应答机制，窗口等保证数据的可靠性。IP协议自身不能保证可靠性，因此 IP 协议可能会出现以下问题： -封包损坏：数据传输过程中被损坏； - 丢包：数据发送过程中都是； -重发：数据被重发，比如中间设备通过两个路径传递数据； -乱序：到达目的地时数据和发送数据不一致；</p><p>但是 IP协议不会去处理这些问题，因为网络层只专注网络层的问题，而且不同特性的应用在不同场景下需要解决的问题不一样。对于网络层，这里有三个问题需要解决：延迟、吞吐量、丢包率。</p><h1 id="ip-协议的工作原理">IP 协议的工作原理：</h1><p>IP 协议接受 IP协议上方的传输层协议会对数据进行一次拆分，这个能力叫做分片。然后 IP协议为每个分片增加 IP 头，组成一个 IP 封包，之后 IP协议调用底层的局域网，也就是数据链路层去传输数据。最后 IP协议通过寻址和路由能力吧封包传输到目的地。</p><h2 id="分片">分片</h2><p>分片：是把数据且分成片，IP协议通过它下层的局域网（链路层）协议传输数据，因此需要适配底层传输网络的传输能力。</p><p>切片完之后，IP 协议会为每个切片添加协议头，其中分为四个部分： -原地址和目标地址，IPv4 的地址是四个 8 位的数字，总共 32位。 - Type ofservice是服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率的搞关系。- IHL 用来描述 IP 协议头的大小，所以 IP 协议头的大小是可变的。 - Totallength 表示报文的长度 <img src="/img/example/network7/network7-1.png"alt="network1" /></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络速通(六) 思考题</title>
    <link href="/2024/10/09/network6/"/>
    <url>/2024/10/09/network6/</url>
    
    <content type="html"><![CDATA[<h2 id="传输层协议-tcp">传输层协议 TCP</h2><ul><li>一台内存在 8G 左右的服务器，可以同时维护多少个连接?<ul><li>在 JAVA 程序中，创建 100W 个连接的速度不会很快，说明创建 TCP连接有成本，需要三次握手，而且这三次握手都有网络的 I/0;</li><li>用 jps 找到对应的进程id，在用 sudo cat /proc/(进程 id)/status | grepVmHWM，可以看到实际的内存占用；</li><li>在单机中建立太多的连接，这时会报一个异常：cannot assign requestedaddress，这是因为客户端在连接服务器端时，操作系统要为每个客户端分配一个端口，上面的程序很快会把端口号用尽，</li></ul></li></ul><p>结论：最核心的问题是：通信需要缓冲区，通信需要I/O，通信占用资源，连接本身占用资源少。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络速通(五) UDP协议：TCP 协议和 UDP 协议的优势和劣势</title>
    <link href="/2024/10/08/network5/"/>
    <url>/2024/10/08/network5/</url>
    
    <content type="html"><![CDATA[<p>TCP 协议的核心：提供了可靠性；UDP 协议的核心：灵活；HTTP协议 1.1 和2.0 都是基于 TCP 的。HTTP3.0 是基于 UDP 的。</p><p>UDP 协议目的是在传输层提供直接发送报文的能力 -报文是数据传输的最小单位 - UDP协议不会帮助拆分数据，他的目标只有一个，就是发送报文</p><h2id="问题为什么不直接调用-ip-协议如果裸发数据ip-协议不香吗">问题：为什么不直接调用IP 协议？如果裸发数据，IP 协议不香吗？</h2><p>回答：传输层协议是在承接上方应用层的调用，需要提供应用到应用的通信，因此要附上端口号，传输层下层的IP 协议承接的是传输层的调用，将数据从主机传输到主机，IP层不能区分应用。</p><p>UDP协议设计的目的：在允许用户直接发送报文的情况下，最大限度地简化应用的设计。<img src="/img/example/network5/network5-1.png" alt="network1" /> -Source Port 是源端口号 - Destination Port 是目标端口号 - Length是消息体长度 - Checksum 是校验和，检查封包是否出错 - Data octets是一个字节一个字节的数据</p><h2 id="校验和">校验和</h2><p>校验和机制：校验数据在传输过程中有没有丢失、损坏，是一个普遍需求。在一次网络会话当中，实际传输的是0 和 1 组成的数字。</p><p>把数据分成一个个 byte，然后将所有的 byte相加，再将最终的结果取反，如果发送方用上述方式计算出Checksum，并将一个个byte和Checksum一起发送给接收方，接收方就可以用同样的算法再计算一遍，这样就可以确定数据有没有发生损坏。</p><p>这种 Checksum 只适用于少量数据变化的情况。</p><p>如果一个数据封包Datagram发生了数据损坏，UDP可以通过Checksum纠错或者修复。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络速通(四) TCP 的稳定性：滑动窗口和流速控制是怎么回事？</title>
    <link href="/2024/10/08/network4/"/>
    <url>/2024/10/08/network4/</url>
    
    <content type="html"><![CDATA[<ul><li>这节讨论如何保证顺序的具体算法</li><li>以及如何在保证顺序的基础上，同时追求更高的吞吐量</li></ul><p>TCP作为一个传输层协议，最核心的能力就是传输，传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供。</p><p>TCP中每个发送的请求都需要响应，如果一个请求没有响应，发送方就会认为发送出现了故障并触发重发，大体的模型如下：<img src="/img/example/network4/network4-1.png" alt="network1" />但如果和下图完全一样，每一个请求收到响应之后，再发送下一个请求，吞吐量就会很低。这样的设计会产生网络很多的空闲资源，也就是浪费带宽。带宽没有用满意味着可以发送更多的请求，接受更多的响应。</p><p>一种改进的方式就是让发送方有请求就发送出去，而不等待响应，通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量也就提升了。<img src="/img/example/network4/network4-2.png" alt="network1" /></p><p>但是如果发送的数据非常多，成百上千个 TCP段都需要发送，这个时候同时发送，这时候带宽可能不足，那应该如何处理？</p><p>这种情况下会考虑使用排队机制（Queuing） 考虑这样一个模型，在 TCP层实现一个队列，新元素从队列的一端进入队列排队，作为一个未发送的数据封包，开始发送的数据封包从队列的另一端离开，可以思考一下这个模型的问题？-这样的问题是需要多个队列，我们要将未发送的数据从队列取出，加入发送中的队列，然后将发送中的数据收到ACK 的部分取出，放入已经收到 ACK 的队列，而发送中的封包何时收到 ACK是一件不确定的事。这样来看，使用队列似乎存在一定的问题。 <imgsrc="/img/example/network4/network4-3.png" alt="network1" /></p><p>在上面的模型当中，之所以觉得算法不好设计是因为用错了数据结构。这里应该用一个叫做滑动窗口的数据结构去实现。<img src="/img/example/network4/network4-4.png" alt="network1" /> -深绿色代表已经收到了 ACK 的段 - 浅绿色代表发送了，但是没有收到 ACK 的段- 白色代表没有发送的段 - 紫色代表暂时不能发送的段</p><p>下面设计不同类型的封包顺序 -将已发送的数据放入最左边，发送中的数据放入中间，未发送的数据放入右边，加入我们同时发送5 个封包，也就是窗口大小等于 5，窗口中的数据被同时发送出去，然后等待ACK，如果一个封包的 ACK 到达，那么就将它标记为已接受 <imgsrc="/img/example/network4/network4-5.png" alt="network1" />这个时候滑动窗口可以向右滑动 <imgsrc="/img/example/network4/network4-6.png" alt="network1" />如果发送过程当中，发送数据如果没有 ACK，那么可能会出发重传 <imgsrc="/img/example/network4/network4-7.png" alt="network1" /> 例如，段 4迟迟没有收到 ACK，这个时候滑动窗口就只能向右移动一个单位。这个时候如果段4 后来重传成功，那么滑动窗口就会右移；如果段 4 还是发送失败，没能收到ACK，那么接收方也会抛弃段 5、6、7 这样从段 4开始之后的数据，都需要重发。 <imgsrc="/img/example/network4/network4-8.png" alt="network1" /></p><p>在 TCP 协议当中，如果接收方想丢弃某个段，可以选择不发ACK，发送端发现超时后，会重发这个 TCP段，有的时候接收方希望催促发送方尽快补发某个 TCP段，这时可以使用快速重传能力。 - 例如：段 1、2、4 到了，但是段 3没有到，接受方可以发送多次段 3 的 ACK，如果发送方收到多个段 3 的ACK，就会重发段3，这个机制称为快速重传。这个和超时重发不同，是一种催促的机制，为了不让发送方误以为段3 已经收到了，在快速重传的机制下，接收方即便收到发来的段 4，依然会发段 3的 ACK，而不发段 4 的 ACK，直到发送方把段 3 重传。</p><h2 id="问题思考">问题思考？</h2><ul><li>窗口大小的单位是多少？</li><li>在上面的图片当中，窗口大小是 TCP 段的数量，实际操作过程当中每个 TCP段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位通常不是多少个段，而是多少个字节。</li></ul><p>发送、接受窗口的大小可以用来控制 TCP协议的流速，窗口越大，同时可以发送、接受的数据就越多，支持的吞吐量就越大。但是窗口越大，数据发送损失也就越大，因为需要重传的数据越多。</p><p>例子：用 RTT表示消息一去一回的时间 <imgsrc="/img/example/network4/network4-9.png" alt="network1" />这时候可以提高窗口的大小来提高窗口的吞吐量，但是实际的模型会比这个复杂，因为还存在重传，丢包等等一些因素。而且实际当中，不可能真的把带宽用完，所以最终选择用折中的方式：在延迟、丢包率、吞吐量进行选择。</p><h1 id="总结">总结</h1><ul><li>有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓冲区接收消息，并发给发送方ACK。</li><li>滑动窗口实现只需要少量的数组、指针即可。</li></ul><h2 id="面试问题">面试问题</h2><p>滑动窗口和流速控制是怎么回事？ - 滑动窗口是 TCP协议控制可靠性的核心，发送方将数据拆包，变成多个分组，然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出的顺序，但是窗口中的分组会一次性发出。窗口中序号最小的分组如果收到ACK，窗口就会发生滑动，如果最小序号的分组长时间没有收到ACK，就会触发整个窗口的数据重新发送。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux 基础使用命令</title>
    <link href="/2024/10/01/tumx/"/>
    <url>/2024/10/01/tumx/</url>
    
    <content type="html"><![CDATA[<h1 id="会话">会话</h1><ul><li>创建会话：tmux new -s session(会话名称)<ul><li>使用 ps aux | grep tmux 可以查看后台启动 tmux 的 server 进程</li></ul></li><li>重新连接会话：tmux attach -t session</li><li>分离当前会话：ctrl b + d 或者 tmux detach</li><li>列出所有会话：ctrl b + s 或者 tmux ls</li><li>重命名当前会话：ctrl b + $ 或者 tmux rename-session -t 0 <new-name>（这个命令将0号会话重命名）</li><li>切换会话：tmux switch -t <session-name></li><li>杀死会话：tmux kill-session -t <session-name></li></ul><h1 id="窗口">窗口</h1><ul><li>划分窗格： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分上下两个窗格</span><br>tmux split-window<br><span class="hljs-comment"># 划分左右两个窗格</span><br>tmux split-window -h<br></code></pre></td></tr></table></figure></li><li>移动光标 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗格</span><br>tmux select-pane -U<br><span class="hljs-comment"># 光标切换到下方窗格</span><br>tmux select-pane -D<br><span class="hljs-comment"># 光标切换到左边窗格</span><br>tmux select-pane -L<br><span class="hljs-comment"># 光标切换到右边窗格</span><br>tmux select-pane -R<br></code></pre></td></tr></table></figure></li><li>交换窗格位置 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>tmux swap-pane -U<br><span class="hljs-comment"># 当前窗格下移</span><br>tmux swap-pane -D<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>tmux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络速通(三) TCP 的封包格式：为什么需要粘包和拆包？</title>
    <link href="/2024/09/30/network3/"/>
    <url>/2024/09/30/network3/</url>
    
    <content type="html"><![CDATA[<h1 id="从稳定性的角度深挖-tcp-协议的运作机制">从稳定性的角度深挖 TCP协议的运作机制</h1><ul><li>如今大半个互联网是建立在 TCP 协议之上，比如使用的HTTP协议、消息队列、存储、缓存都需要用到 TCP 协议。这是因为 TCP协议提供了可靠性，简单来说可靠性就是让数据无损送达。但是考虑到成本，就会变得非常的复杂，因为还需要尽可能的提升吞吐量，降低延迟，减少丢包率。</li><li>TCP 协议就有很强的实用性，可靠性又是 TCP协议最核心的能力，具体来说，从一个终端有序地发出多个数据包，经过一个复杂的网络环境到达目的地的时候，经常会变得无序，而可靠性要求数据又恢复到原始的顺序，在这里就涉及两个问题：<ul><li>TCP 协议是如何恢复数据的顺序的？</li><li>拆包和粘包的作用是什么？</li></ul></li></ul><h2 id="tcp-协议是如何恢复数据的顺序的">TCP协议是如何恢复数据的顺序的？</h2><p>TCP 协议是一个传输层协议，TCP发送数据的时候，往往不是一次将数据一次性发送送达的，而是将数据拆分成很多个部分，再逐个发送，同样的在目的地，TCP协议又需要逐个地接收数据。 <imgsrc="/img/example/network3/network3-1.png" alt="network1" /></p><h3 id="tcp-协议为什么不一次发送完所有数据">TCP协议为什么不一次发送完所有数据？</h3><p>比如：需要传一个大小为 10MB的数据，对于应用层而言，就是一次性传送完成的，而传输层协议为什么不将这个文件一次性发送过去呢？原因如下：1. 为了稳定性，一次发送的数据越多，出错的概率越大； 2.为了效率，拆分数据包就能更好地利用这些并行的路径； 3.发送和接受数据的时候，都存在着缓冲区；（缓冲区是在内存中开辟的一个区域，目的是缓冲，因为大量的应用频繁地通过网卡收发数据，这个时候网卡只能一个个处理应用的请求，当网卡忙不过来的时候，数据就需要排队，也就是要讲数据放入缓冲区，如果每个应用都随意的发送很大量的数据，可能就会导致其他应用的实时性遭到破坏）<img src="/img/example/network3/network3-2.png" alt="network1" /> 4.还有一些原因：在操作系统中，内存的最小分配是页表，如果数据的大小超过一个页表，可能会存在页面置换问题，造成性能损失。<img src="/img/example/network3/network3-3.png" alt="network1" />总之，在传输层封包不能太大，这种限制往往以缓冲区大小为单位，也就是说： -TCP 协议：会将数据拆分成不超过缓冲区大小的一个个部分； -每个部分有一个独特的名词，叫作 TCP 段（TCP Segment）在接受数据的时候，一个个 TCP段又被重组成原来的数据，像这种数据经过拆分，然后传输，然后在目的地重组，我们俗称拆包：- 拆包：将数据拆分成多个 TCP 段传输；那么粘宝是什么？有时候发往一个目的地的多个数据都太小了，为了防止多次发送占用资源，TCP协议有可能将他们合并成一个 TCP 段发送，再在目的地还原成多个数据： -粘包：将多个数据合并成一个 TCP 段发送。 下图是一个 TCP 段的格式： <imgsrc="/img/example/network3/network3-4.png" alt="network1" />我们可以看到 TCP 的很多配置选项和数据粘在了一起，作为一个 TCP段，显然，让你把每一个部分都记住是不太现实的，因此我们只关注最主要的部分：- TCP 协议就是依靠每一个 TCP 段工作的，所有我们每认识一个 TCP的能力几乎都会在 TCP 段找到与之对应的字段。 首先： 1. 源端口（SourcePort）/发送端口（DestinationPort）描述的是发送端口号和目标端口号，代表发送数据的应用程序和接受数据的应用程序；（在TCP 协议中使用端口号来描述发送和接受的应用程序，比如 80 端口往往代表HTTP 服务，22 端口往往代表 SSH 服务）； <imgsrc="/img/example/network3/network3-5.png" alt="network1" /></p><ol start="2" type="1"><li><p>Sequence Number 和 Achnowledgment Number 是保证可靠性的连个关键；<img src="/img/example/network3/network3-6.png"alt="network1" /></p></li><li><p>Data Offset 是一个偏移量，这个量存在的原因如下：</p><ul><li>TCP Header（整个头部的长度）部分的长度是可变的，需要一个数值来描述数据从哪个字节开始； <imgsrc="/img/example/network3/network3-7.png" alt="network1" /></li></ul></li><li><p>Reserved 是很多协议设计会保留的一个区域，用于日后扩展能力； <imgsrc="/img/example/network3/network3-8.png" alt="network1" /></p></li><li><p>URG/ACK/PSH/RST/SYN/FIN 是几个标志位，用于描述 TCP段的行为，也就是 TCP 封包到底是做什么用的？</p><ul><li>URG 代表这个 TCP段是一个紧急数据：比如远程操作的时候，用户其实已经按了 ctrl+c了，代表用户想终止当前的程序，像这种紧急的需求需要加急处理，这时候 URG会置 1；</li><li>ACK 代表响应；</li><li>PSH 代表数据推送，传输数据：代表当前 TCP 段是在传输数据；</li><li>SYN 代表请求同步，申请握手；</li><li>FIN 代表终止请求，挥手。 特别说明：这五个标志位每一个只占了1bit，可以混合使用，比如握手的 ACK-SYN同时为1，代表同步请求和响应。这也是 TCP 协议三次握手，四次挥手的原因。 <imgsrc="/img/example/network3/network3-9.png" alt="network1" /></li></ul></li><li><p>Window 也是 TCP 保证稳定性并进行流量控制的工具；（下一节介绍）<img src="/img/example/network3/network3-10.png"alt="network1" /></p></li><li><p>Checksum 是校验和，用于校验 TCP 段有没有损坏； <imgsrc="/img/example/network3/network3-11.png" alt="network1" /></p></li><li><p>Urgent Pointer 指向最后一个紧急数据的序号号（SequenceNumber）：紧急指针存在的原因是有时候紧急数据它不是一个 TCP段，就好比说有一个紧急数据，它分成了很多个段来传输，这时候需要提前告诉接受方究竟有多少个紧急数据。<img src="/img/example/network3/network3-12.png"alt="network1" /></p></li><li><p>Options 中存储了一些可选字段 （比如：最大分段大小 MSS（MaxiumunSegment Size）） <img src="/img/example/network3/network3-13.png"alt="network1" /></p></li><li><p>Padding 存在的意义是因为 Options 的长度不固定，需要Padding进行补齐； <img src="/img/example/network3/network3-14.png"alt="network1" /></p></li></ol><h3 id="sequence-number-和-achnowledgment-number">Sequence Number 和Achnowledgment Number</h3><p>在 TCP协议的设计当中，数据是被拆分成多个部分的，而每个部分都增加了协议头，将它们合并称之为一个TCP 段，进行传输，这个过程称之为拆包。这些 TCP段经过复杂的网络结构，由底层的 IP协议，负责传输到目的地，然后再进行重组。因此需要思考一个问题：稳定性要求的是数据无损的传输（拆包获得数据，又需要恢复成原来的样子），而在复杂的网络环境当中，即便所有的TCP 段都是顺序发出的，也不能保证它们是顺序到达的，因此发出的每一个 TCP段都需要有序号--Sequence Number(seq)。如下图所示：发送数据的时候，为每一个 TCP 段分配一个自增的 SequenceNumber，接受数据的时候，可以通过 seq 为乱序的 TCP 段进行排序 <imgsrc="/img/example/network3/network3-15.png" alt="network1" /></p><p>但是如果是这样的一种设计又会产生一种新的问题：接收方回复发送方，也去要seq，而网络的两个终端，去同步一个自增的序号是非常困难的，因为任何两个网络主体之间，时间不能做到完全的同步，又没有公共的存储空间，无法共享数据，更别说实现一个分布式自动序号。这个问题的本质就好像两个人在说话，我们要确保他们说出去的话和回答之间的顺序。因为TCP协议是一个双工的协议，两边都可能会同时说话，所以如果想确定一句话的顺序，那么是需要两个值去描述的，也就是发送的字节数和接受的字节数。</p><p>以下是 seq 的设计： <img src="/img/example/network3/network3-16.png"alt="network1" /></p><p>重新定义 seq 如上图所示，对于任何一个接收方，如果知道了发送者发送某个TCP 段时，已经发送了多少字节的数据，那么就可以确定发送者发送数据的顺序。但是这里有一个问题：如果接收方也向发送者发送了数据请求，接收方就不知道发送者发送的数据到底对应哪一条自己发送的数据？举个例子： <img src="/img/example/network3/network3-16.png"alt="network1" /> A 和 B对话，我们可以确定他们彼此之间接受数据的顺序，但是无法确定数据之间的关系，所以只有seq 是不够的，比如说 A 说今天天气好吗，A 又说今天你开心吗，B 说开心，B又说天气不好，对于人类来说去理解这几句话的顺序是非常容易的，但是对于机器就需要特别的标注，因此还需要另一组数据：每个TCP 段发送时，发送方已经接受了多少数据（Achnowledgment Number）。</p><p>下图中，终端发送了三条数据，并且接受了四条数据，通过观察，根据接收到的数据seq 和 ACK，将发送和接受数据可以进行排序。</p><p>例如：发送方发送了 100 字节的数据，而接收到的两个封包（seq = 0 和 seq= 100），都是针对发送方（seq = 0）这个封包的。</p><p>发送 100 个字节，所以接收到的 ACK 刚好是 100，这说明（seq = 0 和 seq= 100）这两个封包其实都是针对接收到第 100字节数据后发送回来的，这样我们就确定了整体的顺序。 <imgsrc="/img/example/network3/network3-18.png" alt="network1" /></p><p>注意：无论是 seq 还是 ACK，都是针对对方而言的。是对方发送数据和对方接受数据。</p><p>我们在实际工作当中可以通过 Whireshark 调试工具观察两个 TCP 连接的 seq和 ACK。 <img src="/img/example/network3/network3-19.png"alt="network1" /></p><h3 id="mssmaxiumun-segment-size">MSS(Maxiumun Segment Size)</h3><ul><li>这也是面试会经常闻到的 TCP Header中的可选项（Options）</li><li>可选项控制 TCP 段的大小，它是一个协商字段（Negotiate）</li></ul><p>协议是双方都要遵循的标准，配置不能由单方决定，需要双方协商。 - TCP段的大小（MSS）涉及发送、接受缓冲区的大小设置 -双方实际发送接受封包的大小，对拆包和粘包的过程有指导作用</p><p>因此需要双方去协商，如果这个字段设置的非常大，会带来一些影响： 1.对方可能会拒绝：对方是服务的提供方，它可能就不愿意接受太大的 TCP段，因为太大的 TCP 段会降低整体的性能，比如说内存的使用性能； <imgsrc="/img/example/network3/network3-20.png" alt="network1" /> 2.资源的占用：用户占用服务器太多的资源，意味着其他用户就需要等待或者降低他们的服务质量；3. 支持 TCP 协议工作的 IP 协议，工作效率会下降；TCP 协议不可拆包，那么IP 协议就需要拆大量的包，那么 IP 协议为什么需要拆包呢？ -在网络当中，每次能够传输的数据不能太大，受限于具体网络传输设备（物理特性）；- 但是对于 IP 协议拆分太多的封包并没有意义，因为可能会导致属于同个 TCP段的封包被用不同的网络线路传输，加大延迟； -同时，拆包需要消耗硬件和计算资源； 4. 是不是 MSS 越小越好？ - MSS太小的情况下，会浪费传输资源（降低吞吐量）。因为数据被拆分之后，每一份数据都要加一个头部，如果MSS越小，那么头部的占比就会上升，这样吞吐量就会成为一个灾难，所以在具体使用的过程当中MSS 的配置往往都是一个折中的方案。</p><h1 id="总结">总结</h1><ul><li>TCP 协议是如何恢复数据的顺序的，TCP拆包和粘包的作用是什么？<ul><li>TCP拆包的作用：将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力，粘包过程需要保证数据经过网络的传输，又能恢复到原始的顺序，这中间需要数学提供保证顺序的理论依据。</li><li>TCP利用（发送字节数、接受字节数）的唯一性来确定封包之间的顺序关系。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络速通(二) 传输层协议 TCP：TCP为什么握手是 3 次，挥手是四次？</title>
    <link href="/2024/09/27/network2/"/>
    <url>/2024/09/27/network2/</url>
    
    <content type="html"><![CDATA[<p>TCP 和 UDP是当今应用最广泛的传输层协议，当今互相网的整个传输层几乎都是基于这两个协议打造的。（应用开发、框架设计选型、做底层和优化，只要碰到网络，肯定逃不开TCP 协议的相关知识）</p><figure><img src="/img/example/network2-1.png" alt="network1" /><figcaption aria-hidden="true">network1</figcaption></figure><h1id="如何理解上图的概念主机到主机连接会话双工单工及可靠性">如何理解上图的概念：主机到主机、连接、会话、双工/单工及可靠性</h1><h2id="主机到主机tcp-提供的是主机到主机的传输一台主机通过-tcp-发送数据给另一台主机">主机到主机：TCP提供的是主机到主机的传输，一台主机通过 TCP 发送数据给另一台主机。</h2><ul><li><p>为什么 TCP往上是应用到应用的协议：例如：微信发消息给张三，微信客户端（微信的聊天服务）他们都是应用。微信有自己的协议（应用到应用的协议）。但是，微信的协议想要工作，就需要一个主机到主机的协议(TCP) 帮他们通信。但 TCP 协议的上层有太多的应用，因此 TCP上层的应用层协议使用 TCP 协议的时候需要告知 TCP是哪个应用--端口号（区分应用）。 <img src="/img/example/network2-2.png"alt="network1" /></p></li><li><p>TCP 要实现主机到主机之间的通信就需要主机们的网络地址（IP地址），但是 TCP 不负责实际地址到地址的传输。因此 TCP 协议把 IP地址交给底层的互联网层（网络层）去处理。</p><ul><li>因此网络层提供的是地址（IP）到地址的通信协议，但是网络层只提供地址到地址的通信，不负责信号在具体的两个设备间传递。</li><li>因此网络层又会调用下方的数据链路层在两个设备之间传递信息，当信号在两个设备间传递的时候，科学家们又设计出物理层去封装最底层的设备、传输介质等，由最下方的物理层提供底层的传输能力。</li><li>以上的五层架构称之为互联网协议群（TCP/IP）协议群</li></ul></li><li><p>总结：主机到主机是为应用提供应用间通信的能力。</p></li></ul><h2 id="连接">连接</h2><ul><li>连接：通信双方的一个约定，目标是让两个在通信的程序之间产生一个契约，保证两个程序都在线而且尽快地响应对方的请求。<ul><li>设计上，连接是一种传输数据的行为，传输之前，建立一个连接，具体来说，数据收发双方的内存中都需要建立一个用于维护数据传输状态的对象。比如说双方的IP和端口是多少？现在发送了多少数据了？状态是健康的吗？传输速度如何？</li></ul></li><li>总结：连接是网络行为状态的记录。</li></ul><h2 id="会话">会话</h2><ul><li>会话：会话是应用的行为，例如张三和你聊天，你和张三建立的是一个会话。你和张三聊天，你们之间创建一个聊天窗口，这个就是会话。当你开始打字的时候，开始传输数据，你和微信服务器之间建立的是一个连接，如果你们聊一段时间，各自休息了，约定先不要关微信，一个小时之后在回来，那么连接是断开的，但是会话没有断开，因为聊天窗口没有关，所以会话还在。<ul><li>在有些系统设计当中，会话会自动重连（也就是重新创建连接），或者帮助创建连接。</li><li>此外，会话也负责在多次连接中保存状态，比如HTTP Session 在多个 HTTP请求（连接）间保持状态。</li></ul></li><li>总结：会话是应用层的概念，连接是传输层的概念。 ##什么是单工？什么是双工？</li><li>在任何一个时刻，数据如果只能单向发送，就是单工，因此单工最少需要一条线路；</li><li>如果在某个时刻可以向一个方向传输，也可以向另一个方向返方向传输，允许这样交替进行，则称之为半双工；至少需要一条线路；</li><li>如果任何时刻的数据都可以收发，则称之为全双工，至少大于一条线路。</li><li>线路，是一个抽象的概念，可以并发地处理信号，达到模拟双工的目的。 TCP是一个双工协议，数据任何时候都可以双向传输。这就意味着服务端和客户端端他们是平等的发送和接收数据。因此客户端和服务端在TCP协议中有一个平等的名词 Host(主机) <imgsrc="/img/example/network2-3.png" alt="network1" /></li></ul><h2 id="什么是可靠性">什么是可靠性？</h2><p>可靠性是指数据保证无损传输。如果发送方按照顺序发送，然后数据无序的在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序。如果发送方同时要把消息发送给多个接收方，这种情况叫多播，可靠性要求每个接收方都无损收到相同的副本。-多播情况具有强可靠性，如果有一个消息到达任何一个接受者，那么所有接受者都必须收到这个消息。</p><h2 id="tcp-的握手和挥手">TCP 的握手和挥手</h2><ul><li>TCP是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。</li><li>TCP 没有设计会话，因为会话通常是一个应用的行为。</li></ul><h3 id="tcp-协议的基本操作">TCP 协议的基本操作</h3><ul><li>如果一个 Host 主动向另一个 Host发起连接，称为SYN(Synchronization)，请求同步。</li><li>如果一个 Host 主动断开请求，称为 FIN(Finish)，请求完成。</li><li>若干一个 Host 给另一个 Host发送数据，称为 PSH(Push)，数据推送。以上三种情况接收方收到数据后，都需要给发送方一个 ACK响应。请求响应是一个可靠性的要求，如果一个请求没有响应，那么发送方会认为自己需要重发这个请求。</li></ul><h3 id="建立连接的过程三次握手">建立连接的过程（三次握手）</h3><p>因为要保持连接的可靠性约束，TCP协议要保证每一条发出的数据必须给返回。返回的数据也叫 ACK 响应。因此建立连接需要三次握手，如下图： 1.首先客户端要发送消息给服务端（SYN）,发送一次同步请求； 2.服务端准备好之后进行连接 3. 服务端针对好客户端的 SYN 给一个ACK(到这里两次握手你可能会觉得足够了，但是其实并不是，因为服务端还不能确定客户端是否准备好了：比如说，步骤三之后，服务端马上给客户端发送数据，这个时候客户端可能还没有好去接收数据，因此还需要增加一个过程)4. 服务端还需要发送一个 SYN 给客户端 5. 客户端准备就绪之后之后 6.客户端给服务端发送一个 ACK</p><p>上述分为六步，步骤一为 1 次握手，步骤三四是同时发生，可以合并为一个SYN-ACK 的响应，作为一条数据传递给客户端，因此算第二次握手，步骤 6算第三次握手。因此建立连接需要三次握手。</p><p>进一步思考：SYN、ACK、PSH 这些常见的表示位，在传输中如何表示： -一种思路：为 TCP 协议增加协议头，在协议头中取多位（bit），其中SYN、ACK、PSH 都占 1 位。如果 SYN 位为 1，则称 SYN开启。这种设计称之为标识(Flag)</p><figure><img src="/img/example/network2-4.png" alt="network1" /><figcaption aria-hidden="true">network1</figcaption></figure><h3 id="断开连接的过程4-次挥手">断开连接的过程（4 次挥手）</h3><p>继续上面的思路，若是客户端要求断开连接： 1. 客户端发送一个 FIN到服务端; 2. 服务端接收到请求之后要马上给客户端一个 ACK 作为 FIN的一个响应（思考：可不可以像握手那样马上传 FIN回去？答案是不能：因为断开连接需要处理的问题比较多，比如说服务端可能还有已经发出但是但是没有收到ACK的消息，也可能服务端有自己的资源需要释放，因此断开连接不能像握手那样操作，将两条消息合并）3. 因此服务端等待，确定关闭连接了在发一条 FIN 给到客户端 4.客户端接收到服务端的 FIN,同时客户端也有可能有自己的事情需要处理完，比如说客户端有发送给服务端，但是没有收到ACK 的请求，客户端自己处理完成之后，在给服务端发送一个 ACK；</p><h1 id="总结">总结</h1><ol type="1"><li>TCP 提供连接（connection），让双方的传输更加稳定、安全；</li><li>TCP没有直接提供会话，因为应用会话的需求多种多样，比如聊天程序会话在保持双方的聊天记录，电商程序会话在保持购物车、订单一致，所以会话通常在TCP 连接上进一步封装，在应用层提供；</li><li>TCP 是一个面向连接的协议，说的就是 TCP协议参与的双方（Host）在收发数据之前会建立连接。后面我还会写一个 UDP协议，UDP是一个面向报文的协议—--协议双方不需要建立连接，直接传送报文（数据）；</li><li>连接需要消耗更多的资源；比如说，在传输数据前，必须先协商建立连接，因此，不是每种场景都应该用连接导向的协议。像视频播放的场景，如果使用连接导向的协议，服务端每向客户端推送一帧视频，客户端都要给服务端一次响应，这是不合理的。</li></ol><h2 id="思考题">思考题</h2><h3 id="tcp-为什么是三次握手4-次挥手">TCP 为什么是三次握手，4次挥手？</h3><ul><li>TCP是一个双工协议，为了让双方都保证，建立链接的时候，连接双方都需要向对方发送SYC(同步请求) 和ACK（响应），握手阶段双方都没有反锁的工作，因此一方向另一方发起同步（SYC）之后，另一方可以将自己的SYC 和 ACK 打包作为一条消息回复，因此 3 次握手—--需要三次数据传输；</li><li>挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上做出回应（ACK），表示接收到了挥手请求。类比现实世界中，你收到一个offer，出于礼貌你先回复考虑一下，然后思考一段时间再回复 HR最后的结果。最后等待所有工作结束，再发送请求中断连接（FIN），因此是 4次挥手。 <img src="/img/example/network2-5.png" alt="network1" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络速通(一) 什么是蜂窝移动网络？</title>
    <link href="/2024/09/27/network1/"/>
    <url>/2024/09/27/network1/</url>
    
    <content type="html"><![CDATA[<h1 id="网络的组成">网络的组成</h1><ul><li><p>网络可以看成一张巨大的网，细看这个网，这个网里面还有很多小型的网络。用无数个小型的网络组成一个中型网络，再又许多中型的网络组成一个大型的网络。分析一个小型网络，公司网络，如下图：公司网络从本地网络提供商接入，然后内部再分成一个个子网，所看到的线路被称为通信链路，用于传输网络信号。<img src="/img/example/network1.png" alt="network1" /></p></li><li><p>这时候观察到有的节点同时接入两两条以上的链路，这个时候因为链路已经发生了分叉，数据传输到这些节点需要选择方向，因此我们称这些节点需要进行交换（Switch）。</p></li><li><p>数据发生交换的时候会从一条链路进入交换设备然后缓存下来，再转发切换到另一条路径，如下图所示。</p></li><li><p>交换技术的本质：让数据切换路径。因为网络中的数据是以分组或封包（Packet）的形式进行传输。因此也称这个技术为封包交换（PacketSwitch）。比如说需要传递一首 MP3格式的歌曲，歌曲本身不是一次性传输完成的，而是被拆分成很多个封包，每个封包只有歌曲中的部分数据，而封包一旦遇到岔路口，就需要封包交换技术，帮助每个封包选择最合理的路径。</p></li><li><p>常见具有交换能力的设备：链路层交换机和路由器。通常情况下，两个网络可以通过路由器进行连接，多个设备也可以通过交换机进行连接。路由器通常也具有交换机的功能。<img src="/img/example/network2.png" alt="network1" /></p></li><li><p>在下图中，公司内部的网络被分成多级子网，每个路由器交换机构成了一级子网，最高级的路由器在公司的网络边缘，它可以将网络内部节点连接到其他网络（外部的网络）。</p></li><li><p>本地网络提供商（ISP）提供的互联网先到达边缘路由器，然后再渗透到内部的网络节点</p></li><li><p>公司内部若干服务器可以通过交换机形成一个局域网络。公司内部的办公设备（笔记本、电脑）也可以通过无线路由器或者交换机形成一个局域网。局域网络之间可以通过路由器、交换机进行连接，从而构成一个更大的局域网络。<img src="/img/example/network3.png" alt="network1" /></p></li></ul><h1 id="移动网络">移动网络</h1><ul><li>网络传输需要通信链路。通信链路是一个抽象的概念（类似面向对象中抽象类和继承类的关系）。</li><li>同轴电缆、无线信号的发送接收器、蓝牙信道都是通信链路。</li><li>在移动网络中，无线信号构成了通信链路。<ul><li>在移动网络的设计当中，通信的核心被称之为蜂窝塔，也称做基站。</li></ul></li><li>构成移动网络最小的网络（蜂窝网）如下图所示：国家或全球网络提供商将网络提供给处于蜂窝网络边缘的路由器，而路由器再连接蜂窝塔，再通过蜂窝塔提供给六边形区域内的设备。（通常是国家级别的网络服务提供商负责部署基站：中国电信等等 ）。<ul><li>将网络提供给一个子网的行为称为网络提供。（比如运营商给家里装宽带）。</li><li>对一个子网连接提供商的网络，称为网络接入。 <imgsrc="/img/example/network4.png" alt="network1" /></li></ul></li><li>家用网络 移动网络 公司网络的关系 <imgsrc="/img/example/network5.png" alt="network1" /></li></ul><h1 id="数据的传输">数据的传输</h1><p>上述的网络中有庞大的个人公司组织基站形成的网络，在这些网络当中传递数据不是一件容易的事，为了传递数据，在网络当中有几个特别重要的抽象- 最终提供服务或者享受服务的设备：终端（Terminal）、端系统（EndSystem）、主机（Host）。</p><p>网络传输可以分为两类： - 端到端（Host to Host）的能力，又 TCP/IP协议群提供 - 一对多、多对多的能力，是端到端（Host to Host）能力的延生想象一下，一个北京的 Host 向深圳的 Host发送消息，那么中间会穿越大量的网络节点（路由器、交换机、基站），在发送消息的过程当中可能会跨越很多个网络，通过很多个网络边缘，可能会通过不同的网络提供商提供的网络，而且传输过程中可能还会有不同材质的通信链路（同轴电缆、双绞线、光纤、或者无线传输的Wi-Fi、卫星）。</p><p>网络基础设施往往不能一次性传输太大的数据量，通常会将数据分片传输，比如传输一个MP3，会将 MP3内容且分成很多个组，每个组称作为一个封包，这样其中一个封包损坏，就只需重发损坏的封包，而不需要重发所有的数据。另一方面，网络中两点的路径是非常多的，如果一条路径阻塞了，部分封包可以考虑走其他路径，发送端将数据拆分成封包，封包在网络中遇到岔路，有交换机或路由器节点决定走向。<img src="/img/example/network6.png" alt="network1" /></p><h1 id="总结">总结</h1><p>互联网是一个庞大的结构：整体来看，互联网是一个立体的、庞大的网状结构；微观层面：一个个网络、一台台设备。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile 基础</title>
    <link href="/2024/09/26/makefile/"/>
    <url>/2024/09/26/makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile-基础命令-语法">Makefile 基础命令-语法</h1><ul><li><p>数据类型，字符串和字符串数组；</p></li><li><p>定义变量：定义变量 val，为 string 类型，值为folder；<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">val := folder<br></code></pre></td></tr></table></figure></p></li><li><p>定义数组：定义变量 val，为数组类型，值是["hello", "world","folder"] <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">val := hello world folder<br></code></pre></td></tr></table></figure></p></li><li><p>定义的方式有多种：</p><ul><li>= 赋值： val =folder，递归赋值，val的值赋值后并不马上生效，等到使用时才真正的赋值（不常用）；例子：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = <span class="hljs-variable">$(y)</span><br>y = hello<br></code></pre></td></tr></table></figure>此时x的值是hello，可以这样理解：使用等号赋值的时候makefile在分析完整个文件后再把变量展开；</li><li>:= 赋值：val :=folder，基本赋值，当前所在位置决定取值（常用）；</li><li>?= 赋值：val ?= folder，如果没有赋值，则赋值为 folder；</li><li>+= 赋值：val += folder，添加值，在 val 后面添加值；例子：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">val := hello<br>val += world<br></code></pre></td></tr></table></figure> 此时，val 的结果为 hello world；</li></ul></li><li><p>$(val)：解析 val 的值；</p></li><li><p>$(func param)：调用 Make 提供的内置函数；</p><ul><li>例如：<ul><li>定义 val 的值为执行shell echo hello后的输出： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">val := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo hello)</span><br></code></pre></td></tr></table></figure></li><li>直接打印 val 变量的内容： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(info <span class="hljs-variable">$(val)</span>)</span><br></code></pre></td></tr></table></figure></li><li>替换 aabbcc 种的 a 为 x 后赋值给 val，结果为 xxbbcc：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">val := <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> a, x, aabbcc)</span><br></code></pre></td></tr></table></figure></li><li>逻辑语法：ifeq、ifneq、ifdef、ifndef <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span>(<span class="hljs-variable">$(val)</span>, depends)<br>    name := hello<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure> # 案例<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义变量a, 赋值为 folder</span><br>a := folder<br><span class="hljs-comment"># 为变量 a 增加内容 directory, 结果是：folder directory</span><br>a += directory<br><span class="hljs-comment"># 定义变量 b, 为字符串拼接，结果是：beginfolder drectoryend</span><br>b := begin<span class="hljs-variable">$(a)</span>end<br><span class="hljs-comment"># 定义变量 c, 为执行 ls 指令后的输出字符串</span><br>c := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> ls)</span><br><span class="hljs-comment"># 定义变量 d, 为把 xiao 中的 x 替换为a, 结果是：aiao</span><br>d := <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> x, a, xiao)</span><br><span class="hljs-comment"># 定义变量e, 为在 a 的每个元素前面增加 -L 符号, 结果是：-Lfolder -Ldirectory</span><br>e := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -L%, <span class="hljs-variable">$(a)</span>)</span><br><span class="hljs-comment"># 打印变量 e 的内容</span><br><span class="hljs-variable">$(info e = $&#123;e&#125;)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>生成项可以没有依赖项，那么如果该生成项文件不存在，command将永远执行</p></li></ul><h1 id="依赖关系定义">依赖关系定义</h1><ul><li>依赖关系定义： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a.o: a.cpp</span><br>    @echo 编译 a.cpp, 生成 a.o<br>    g++ -c a.cpp a.o<br></code></pre></td></tr></table></figure><ul><li>第一次执行make a.o时，由于a.o不存在，执行了command；</li><li>第二次执行make a.o时，由于a.cpp时间没有比a.o新，打印a.o is up todate，不需要编译；</li><li>生成项和依赖项，从来都是当成文件来看待的；</li></ul></li></ul><h1 id="编译和链接结合起来">编译和链接结合起来</h1><ul><li><p>根据 out.bin 推导其依赖是 a.o b.o</p></li><li><p>根据 a.o 推导其依赖项是 a.cpp, 执行编译 a.cpp</p></li><li><p>根据 b.o 推导其依赖项是 b.cpp, 执行编译 b.cpp</p></li><li><p>有了 a.o 和 b.o 后, 链接成 out.bin</p><p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a.o: a.cpp</span><br>    @echo 编译 a.cpp, 生成 a.o<br>    g++ -c a.cpp a.o<br><span class="hljs-section">b.o: b.cpp</span><br>    @echo 编译 b.cpp, 生成 b.o<br>    g++ -c b.cpp b.o<br><span class="hljs-section">out.bin: a.o b.o</span><br>    @echo 链接 a.o, b.o, 生成 out.bin<br>    g++ a.o b.o -o out.bin<br></code></pre></td></tr></table></figure></p></li><li><p>定义好依赖后makeout.bin后，会自动查找依赖关系，并自动按照顺序执行command</p></li><li><p>这是makefile为我们解决的核心问题，剩下就是如何玩的更方便罢了。比如自动检索a.cpp、b.cpp，自动定义a.o依赖a.cpp。等等</p></li></ul><h1 id="总结">总结</h1><ul><li>变量赋值有4种方式var = 123, var := 123, var ?= 123, var +=123。其中var := 123常用，var += 123常用</li><li>取变量值有两种，<spanclass="math inline">\((var)，\)</span>{var}。小括号大括号均可以</li><li>数据类型只有字符串和字符串数组，空格隔开表示多个元素</li><li>$(functionarguments)是调用make内置函数的方法，具体可以参考官方文档的函数大全。但是常用的其实只有少数两个即可</li><li>依赖关系定义中，如果代码修改时间比生成的更新/生成不存在时，command会执行。否则只会打印main.ois up to date。这是makefile解决的核心问题</li><li>依赖关系可以链式的定义，即b依赖a，c依赖b，而make会自动链式的查找并根据时间执行command</li><li>command是shell指令，可以使用$(var)来将变量用到其中。前面加@表示执行执行时不打印原指令内容。否则默认打印指令后再执行指令</li><li>make不写具体生成名称，则会选择依赖关系中的第一项生成</li></ul>]]></content>
    
    
    <categories>
      
      <category>Makefile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建多线程</title>
    <link href="/2024/09/06/thread-2/"/>
    <url>/2024/09/06/thread-2/</url>
    
    <content type="html"><![CDATA[<h3 id="c中的多线程">C++中的多线程</h3><p>传统的C++（C++11标准之前）中并没有引入线程这个概念，在C++11出来之前，如果我们想要在C++中实现多线程，需要借助操作系统平台提供的API，比如Linux的，或者windows下的。</p><h3 id="c中线程的创建">C++中线程的创建</h3><p>使用std::thread类：这是C++11及以后版本推荐的方式。你可以直接创建一个std::thread对象来启动一个新的线程，并传递一个可调用对象（如函数、函数对象、Lambda表达式等）作为线程的执行体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>  </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_function</span><span class="hljs-params">()</span> </span>&#123;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from thread!\n&quot;</span>;  <br>&#125;  <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-comment">// mian 所在的线程就是主线程（控制线程）</span><br>   <span class="hljs-comment">// 初始化一个子线程，让这个子线程执行thread_function函数</span><br>    <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(thread_function)</span></span>;<br>    t.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 阻塞当前线程，等待子线程执行完毕</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main thread exit&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>mian 其实就是一个主线程</li><li>thread t(thread_function)传入的参数为可调用对象：lambda表达式、仿函数</li><li>t.join()阻塞当前线程，等待子线程执行完之后，主线程才继续往下执行</li></ul><h3 id="线程的可调用对象">线程的可调用对象</h3><p>在C++中，线程的可调用对象（callableobject）可以是多种类型，包括但不限于：函数指针、成员函数指针、lambda表达式、函数对象（也称为仿函数或functor）以及绑定对象（通过std::bind创建）。以下是一些示例代码：- 函数指针 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionPointerTask</span><span class="hljs-params">()</span> </span>&#123;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Function pointer task executed.\n&quot;</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(functionPointerTask)</span></span>;  <br>    t.<span class="hljs-built_in">join</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> - 成员函数指针 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>  </span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memberFunctionTask</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Member function task executed.\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    MyClass obj;  <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;MyClass::memberFunctionTask, &amp;obj)</span></span>; <span class="hljs-comment">// 注意：需要传递对象指针  </span><br>    t.<span class="hljs-built_in">join</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> - Lambda表达式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() &#123;  </span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;Lambda task executed.\n&quot;</span>;  </span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;  <br>    t.<span class="hljs-built_in">join</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> - 函数对象（仿函数） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>  </span><br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Functor</span> &#123;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Functor task executed.\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Functor f;  <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(f)</span></span>;  <br>    t.<span class="hljs-built_in">join</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> -绑定对象（通过std::bind） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionWithArgs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Function with args: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">auto</span> boundFunc = std::<span class="hljs-built_in">bind</span>(functionWithArgs, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(boundFunc)</span></span>;  <br>    t.<span class="hljs-built_in">join</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>请注意，从C++11开始，<thread>库是C++标准库的一部分，用于处理线程。在创建线程时，你需要传递一个可调用对象给std::thread的构造函数。可调用对象可以是上述任何一种类型。</p>]]></content>
    
    
    <categories>
      
      <category>C++进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++进阶</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础</title>
    <link href="/2024/09/06/thread-1/"/>
    <url>/2024/09/06/thread-1/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是线程">什么是线程</h3><ul><li>线程（Thread）是操作系统能够运行调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</li></ul><h3 id="进程与线程的关系">进程与线程的关系</h3><ul><li>进程：程序的运行最终要调到内存中执行，调到内存中执行的程序就是一个进程。</li><li>在多线程编程中，一个进程（process）可以包含多个线程（thread）（通俗讲就是多个任务：例如TIM，你可以同时打字聊天、打视频），这些线程共享相同的进程空间（包括代码段、数据段、堆、栈等）和系统资源（如文件描述符号和信号处理），但各自有独立的栈空间和线程控制块（TCB）。</li><li>每个进程默认会有一个主线程（控制线程：创造更多的子线程）。 ####他们之间的关系</li><li>每个进程都有相应的线程，进程是线程的容器；</li><li>进程是资源分配的最小单位，而线程是程序执行的最小单位；</li><li>进程有自己独立的地址空间，而线程没有独立的地址空间，同一进程的线程共享本进程的地址空间；</li><li>进程之间的资源是独立的；而同一进程内的线程共享本进程的资源；</li><li>进程可以并发执行，同一进程内的多个线程也可以并发执行。</li></ul><h3 id="线程的特点">线程的特点</h3><ul><li>轻量级：与进程相比，线程的创建和销毁成本较低，因为线程是进程的一个执行流，共享进程的大部分资源，只需要少量的额外开销来维护线程的状态和控制信息。</li><li>共享资源：同一进程内的线程共享进程地址空间和全局变量等资源，这使得线程间通信更加便捷，但是这样带来了数据同步和互斥的问题，需要使用适当的同步机制来避免数据竞争和死锁等问题。</li><li>并发执行：多个线程可以在同一时间内并发执行，提高了程序的执行效率。但是，由于线程的执行顺序和速度受到操作系统调度策略和硬件性能的影响，因此线程的执行结果可能是不确定的。</li><li>独立调度：线程是独立调度的基本单位，在多线程操作系统中，调度器根据线程的优先级、状态等因素来决定线程的调度顺序和执行时间。</li><li>系统支持：现代操作系统通常提供了对线程的支持，包括线程的创建、销毁、调度、同步等功能的API 接口。</li></ul><h3 id="什么是多线程编程">什么是多线程编程？</h3><ul><li>多线程编程是指在一个程序中创建多个线程并发的执行，每个线程执行不同的任务。线程是操作系统能够进行运算调度的最小单位，一个进程中可以包含多个线程，每个线程都是进程中的一个单一顺序的控制流。多线程编程的主要目的是提高程序的执行效率和响应速度，使得程序能够充分利用CPU资源。</li></ul><h3 id="为什么要是用多线程">为什么要是用多线程？</h3><ul><li>充分利用 CPU资源：多线程编程可以让程序在多个线程之间并发执行，从而充分利用 CPU的多核或多处理器资源，提高程序的执行效率。</li><li>提高程序的响应速度：多线程编程可以将占据时间长的任务放到后台执行，使得响应用户请求的线程能够尽快处理外成，缩短响应时间，提升用户体验。</li><li>便于程序的设计和维护：多线程编程可以将复杂的程序分解为多个相对独立的线程，每个线程负责完成特定的任务，从而简化程序设计和维护的难度。</li></ul><h3 id="线程与-cpu-执行关系">线程与 CPU 执行关系</h3><ul><li>CPU 调度单位：线程是 CPU调度的最小单位。这意味着操作系统根据一定的调度算法，将 CPU的执行时间分配给各个线程，使得他们能够并发执行。</li><li>单核 CPU 与多线程：在单核 CPU上，多个线程实际上是并发而非真正的同时进行。这是因为 CPU会在不同的线程之间快速切换，每次只执行一个线程的一部分，然后切换到另一个线程。由于切换速度非常快，用户通常感觉多个线程是同时运行的。这种技术成为时间片轮转（Time-Slicing）或多任务处理（Multi-Tasking）。</li><li>多核 CPU 与多线程：在多核 CPU上，多个线程可以同时运行，因为每个线程可以被分配给不同的 CPU核心去执行。这样，多个线程可以同时进行复杂的计算任务，从而大大提高整体性能。</li><li>线程优先级：操作系统会根据线程的优先级来决定执行顺序。优先级高的线程会获得更多的CPU 时间片，从而更加频繁地执行。</li><li>线程同步与互斥：当多个线程需要访问共同资源时，就需要考虑线程同步和互斥的问题。这是因为如果没有适当的同步机制，多个线程可能会同时修改一个数据，导致数据不一致或错误。常用的线程同步机制包括互斥锁、条件变量、信号量等。</li></ul><h3 id="线程的生命周期">线程的生命周期</h3><p>线程的生命周期通常包括以下几个阶段： -新建资源（New）：当线程对象被创建时，他处于新建状态。此时，线程还没有开始执行，也没有分配任何资源。- 就绪状态（Runnable）：当线程对象调用了start()方法后，它进入就绪状态。此时，线程已经做好了执行的准备，等待操作系统调度执行。- 运行状态 （Running）：当线程获得 CPU时间片时，它进入运行状态。此时，线程开始执行其任务，直到任务完成或遇到阻塞条件。- 阻塞状态（Blocked）：当线程在执行过程中遇到某些阻塞条件（如等待 I/O操作完成、等待获取某个锁等）时，它进入阻塞状态。此时，线程暂停执行，并释放CPU 资源，直到阻塞条件消失并重新获得 CPU 时间片。 -死亡状态（Dead）：当线程执行完其任务或遇到异常导致退出时，他进入死亡状态。此时，线程资源被回收，生命周期结束。</p>]]></content>
    
    
    <categories>
      
      <category>C++进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++进阶</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试八股篇（上）</title>
    <link href="/2024/09/06/cpp-interview-1/"/>
    <url>/2024/09/06/cpp-interview-1/</url>
    
    <content type="html"><![CDATA[<h3 id="指针占用的大小是多少">指针占用的大小是多少？</h3><ul><li>并不固定，取决于使用的操作系统和编译器以及程序运行的平台，指针的占用大小通常与特定系统上的地址空间的大小和寻址方式有关；</li><li>在 32 位系统上，指针通常为 4 个字节（32 位），足够覆盖32位系统上所有内存地址；</li><li>而 64 位系统上为 8 个字节（64位），虽然远远超过当前实际可用的内存量，但为未来的扩展提供了空间；</li><li>可以用 sizeof(&amp;变量)运算符查看。</li></ul><h3 id="解释c中的继承和多态性">解释C++中的继承和多态性</h3><h4 id="继承">继承</h4><ul><li>允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法通过继承，子类可以获得父类所有的公有成员，并可以添加自己额外成员。</li><li>继承方式：有三种：公有继承（public）、私有继承（private）、保护继承（protected）。这些方式的区别在于决定了基类成员在派生类中的访问权限。</li><li>基类和派生类的关系：基类通常表示一般化的概念，而派生类则表示具体的概念。</li><li>继承和多态的关系：多态要实现，首先得有继承关系存在。</li></ul><h2 id="多态性">#### 多态性</h2><h3id="explicit关键字用在哪里有什么用">explicit关键字用在哪里，有什么用？</h3><ul><li>在 C++中explicit关键字主要用在构造函数前面，防止类构造函数的意外调用。</li><li>举例说明</li></ul><h3id="什么是虚函数为什么要在基类中使用虚函数">什么是虚函数？为什么要在基类中使用虚函数？</h3><h3id="如何处理内存泄露问题提供一些常见的内存管理技术">如何处理内存泄露问题？提供一些常见的内存管理技术。</h3><h3 id="解释堆与栈之间的区别">解释堆与栈之间的区别。</h3><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>C++面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode 基于 CMake 配置 C++ 调试环境</title>
    <link href="/2024/08/30/vscode-cpp/"/>
    <url>/2024/08/30/vscode-cpp/</url>
    
    <content type="html"><![CDATA[<h2 id="配置-vscode-相关-c插件">配置 vscode 相关 C++插件</h2><ul><li>vscode 插件商店下载 <strong>C++</strong>、 <strong>C/C++ ExtensionPack</strong>、<strong>CMake</strong>、<strong>CMakeHighlight</strong>、<strong>CMake LanguageSupport</strong>、<strong>CMaketools</strong>、<strong>MakefileTools</strong>插件。</li></ul><h2 id="配置-vscode相关配置文件">配置 vscode相关配置文件</h2><ul><li><p>launch.json：主要修改program关键字 debug程序的路径，preLaunchTask关键字：在 debug 之前需要运行的任务。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lldb&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 指定调试器类型为LLDB。</span><br>            <span class="hljs-comment">// &quot;launch&quot;：表示启动一个新的程序进行调试。</span><br>            <span class="hljs-comment">// &quot;attach&quot;：表示附加到一个正在运行的进程进行调试。</span><br>            <span class="hljs-comment">// &quot;custom&quot;：表示执行一个自定义的调试请求。</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启动一个新的程序进行调试</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C++ CMake Debug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//调试启动 name，无所谓随便取</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Build/cmake_debug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//需要debug的程序，修改程序路径</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 添加一些参数命令</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 这指定程序的工作目录</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CMake: 构建&quot;</span> <span class="hljs-comment">// 启动调试之前要运行的任务，关联到 tasks.json</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>task.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// type 关键字:</span><br> <span class="hljs-comment">// shell: 表示该任务是一个 shell 命令，将在终端中执行。</span><br><span class="hljs-comment">// process: 表示该任务是一个进程，将在后台运行。</span><br><span class="hljs-comment">// cppbuild: 表示该任务是一个 C++ 构建任务，用于构建 C++ 项目。</span><br><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-comment">// 1. cmake 配置</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CMake: 配置&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启动命令为 cmake</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;-DCMAKE_BUILD_TYPE=Debug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// cmake 对应的一些参数</span><br><span class="hljs-string">&quot;-S .&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;-B Build&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$msCompile&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">// 2. cmake 构建</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CMake: 构建&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;--build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;Build&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$msCompile&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;CMake: 配置&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">// 3. 删除Build目录</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;删除Build目录&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;-rf&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;Build&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$msCompile&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">// 4. 运行可执行文件</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;运行可执行文件&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./Build/cmake_debug&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$msCompile&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;CMake: 构建&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>c_cpp_properties.json：主要是includePath需要写入包含库的头文件路径，能够让vscode识别到。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Mac&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;/opt/homebrew/Cellar/opencv/4.10.0_2/include/opencv4/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;macFrameworkPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clang&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;macos-clang-arm64&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;configurationProvider&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ms-vscode.cmake-tools&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="运行生成任务">运行生成任务</h2><p>Mac vscode快捷键：command+shift+B则可看到对于的生成任务，打好断点后，就能够调试程序了。<imgsrc="/img/example/vscode.png" alt="vscode构建" /></p>]]></content>
    
    
    <categories>
      
      <category>vscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Linux转发X11图形界面调试方法</title>
    <link href="/2024/08/30/docker_X11/"/>
    <url>/2024/08/30/docker_X11/</url>
    
    <content type="html"><![CDATA[<h2 id="下载xquartz">下载XQuartz</h2><p>由于我的电脑是 Mac，因此下载<ahref="https://www.xquartz.org/">XQuartz</a>工具来作为转发工具。</p><h2 id="构建容器">构建容器</h2><ul><li>在拉去 docker 镜像后，构建镜像容器需运行以下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 10001:22 -gpus all --shm-size=8G -it --ipc=host --net=host \<br>-v /your_local_path/:/your_env_path \<br>-v /tmp/.X11-unix:/tmp/.X11-unix \<br>-e DISPLAY=unix<span class="hljs-variable">$DISPLAY</span> \<br>-e GDK_SCALE \<br>-e GDK_DPI_SCALE \<br>--name your_container_name your_images_id /bin/bash<br></code></pre></td></tr></table></figure><p>主要就是将<em>your_container_name</em>替换为自己想要的容器名称，<em>your_images_id</em>替换为pull 下来的镜像 ID。如果还需挂在磁盘使用-v 命令就可以了。</p><h2 id="配置-ssh">配置 SSH</h2><ul><li>通常我们采用 SSH 远程连接服务器，需要修改客户端SSH配置，配置文件一般在~/.ssh/config，样例如下：</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Host</span> <span class="hljs-number">3090</span><br>    HostName <span class="hljs-comment">#修改为对于的服务器 IP</span><br>    User <span class="hljs-comment">#修改对应的登录用户</span><br>    Port <span class="hljs-number">22</span><br>    ForwardX11Trusted <span class="hljs-literal">yes</span><br>    ForwardAgent <span class="hljs-literal">yes</span><br>    ForwardX11 <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h2 id="运行终端导入环境变量">运行终端导入环境变量</h2><ul><li>在运行程序前，导入环境变量：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DISPLAY=localhost:0.0<br></code></pre></td></tr></table></figure><p>就能实现图像转发。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>X11转发</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客说明</title>
    <link href="/2024/08/29/announcement/"/>
    <url>/2024/08/29/announcement/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的个人小站！我会在这里分享日常生活、技术心得以及个人兴趣。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
